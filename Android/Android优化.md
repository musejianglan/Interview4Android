
### ANR
ANR的全称application not responding 应用程序未响应。

* 在android中Activity的最长执行时间是5秒。
* BroadcastReceiver的最长执行时间则是10秒。
* Service的最长执行时间则是20秒。
> 超出执行时间就会产生ANR。注意：ANR是系统抛出的异常，程序是捕捉不了这个异常的。

#### a.解决方法:

1. 运行在主线程里的任何方法都尽可能少做事情。特别是，Activity应该在它的关键生命周期方法 （如onCreate()和onResume()）里尽可能少的去做创建操作。（可以采用重新开启子线程的方式，然后使用Handler+Message 的方式做一些操作，比如更新主线程中的ui等）
2. 应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。但不再是在子线程里做这些任务（因为 BroadcastReceiver的生命周期短），替代的是，如果响应Intent广播需要执行一个耗时的动作的话，应用程序应该启动一个 Service。


### FC（Forced Close）
原因 


1. Error 【OOM(out of memory error)内存耗尽 & StackOverFlowError堆栈溢出】
2. RuntimeException



### OOM（OutOfMemory）

解决OOM的常用方案

内存限制是Android对应用的一个系统级限制，作为应用层开发人员，没有办法彻底去消灭这个限制，但是可以通过一些手段去合理使用内存，从而规避这个问题。以下是个人总结的一些常用方法：

(1)缓存图像到内存，采用软引用缓存到内存，而不是在每次使用的时候都从新加载到内存；

(2)调整图像大小，手机屏幕尺寸有限，分配给图像的显示区域本身就更小，有时图像大小可以做适当调整；

(3)采用低内存占用量的编码方式，比如Bitmap.Config.ARGB_4444比Bitmap.Config.ARGB_8888更省内存；

(4)及时回收图像，如果引用了大量Bitmap对象，而应用又不需要同时显示所有图片，可以将暂时用不到的Bitmap对象及时回收掉；

(5)自定义堆内存分配大小，优化Dalvik虚拟机的堆内存分配；

### Listview、RecycleView的优化，与scollview的区别
* 使用ViewHolder模式提高效率。
* 耗时的操作放在异步线程中
* ListView的滑动时停止加载和分页加载
* 为图片设置缓存
* listView错位加载问题

### 卡顿优化
卡顿的场景有很多，按场景可以分为4类：UI 绘制、应用启动、页面跳转、事件响应，如图：
![卡顿场景](https://github.com/musejianglan/Interview4Android/blob/master/img/卡顿场景.png)

这4种卡顿场景的根本原因可以分为两大类：

* 界面绘制。主要原因是绘制的层级深、页面复杂、刷新不合理，由于这些原因导致卡顿的场景更多出现在 UI 和启动后的初始界面以及跳转到页面的绘制上。
* 数据处理。导致这种卡顿场景的原因是数据处理量太大，一般分为三种情况，一是数据在处理 UI 线程，二是数据处理占用 CPU 高，导致主线程拿不到时间片，三是内存增加导致 GC 频繁，从而引起卡顿。

卡顿根本原因
根据Android 系统显示原理可以看到，影响绘制的根本原因有以下两个方面：

* 绘制任务太重，绘制一帧内容耗时太长。
* 主线程太忙，根据系统传递过来的 VSYNC 信号来时还没准备好数据导致丢帧。


#### 布局优化
主要通过减少层级、减少测量和绘制时间、提高复用性三个方面入手。

* 减少层级。合理使用 RelativeLayout 和 LinerLayout，合理使用Merge。
* 提高显示速度。使用 ViewStub，它是一个看不见的、不占布局位置、占用资源非常小的视图对象。
* 布局复用。可以通过 标签来提高复用。
* 尽可能少用wrap_content。wrap_content 会增加布局 measure 时计算成本，在已知宽高为固定值时，不用wrap_content 。
* 删除控件中无用的属性。

#### 避免过度绘制
过度绘制是指在屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构中，如果不可见的 UI 也在做绘制的操作，就会导致某些像素区域被绘制了多次，从而浪费了多余的 CPU 以及 GPU 资源。  

* 布局上的优化。移除 XML 中非必须的背景，移除 Window 默认的背景、按需显示占位背景图片
* 自定义View优化。使用 canvas.clipRect()来帮助系统识别那些可见的区域，只有在这个区域内才会被绘制。

### 内存优化
#### 常见内存泄漏场景
如果在内存泄漏发生后再去找原因并修复会增加开发的成本，最好在编写代码时就能够很好地考虑内存问题，写出更高质量的代码，这里列出一些常见的内存泄漏场景，在以后的开发过程中需要避免这类问题。

* 资源性对象未关闭。比如Cursor、File文件等，往往都用了一些缓冲，在不使用时，应该及时关闭它们。
* 注册对象未注销。比如事件注册后未注销，会导致观察者列表中维持着对象的引用。
* 类的静态变量持有大数据对象。
* 非静态内部类的静态实例。
* Handler临时性内存泄漏。如果Handler是非静态的，容易导致 Activity 或 Service 不会被回收。
* 容器中的对象没清理造成的内存泄漏。
* WebView。WebView 存在着内存泄漏的问题，在应用中只要使用一次 WebView，内存就不会被释放掉。

#### 优化内存空间

没有内存泄漏，并不意味着内存就不需要优化，在移动设备上，由于物理设备的存储空间有限，Android 系统对每个应用进程也都分配了有限的堆内存，因此使用最小内存对象或者资源可以减小内存开销，同时让GC 能更高效地回收不再需要使用的对象，让应用堆内存保持充足的可用内存，使应用更稳定高效地运行。常见做法如下：

* 对象引用。强引用、软引用、弱引用、虚引用四种引用类型，根据业务需求合理使用不同，选择不同的引用类型。
* 减少不必要的内存开销。注意自动装箱，增加内存复用，比如有效利用系统自带的资源、视图复用、对象池、Bitmap对象的复用。
* 使用最优的数据类型。比如针对数据类容器结构，可以使用ArrayMap数据结构，避免使用枚举类型，使用缓存Lrucache等等。
* 图片内存优化。可以设置位图规格，根据采样因子做压缩，用一些图片缓存方式对图片进行管理等等。

### 安装包大小优化

* 代码混淆。使用proGuard 代码混淆器工具，它包括压缩、优化、混淆等功能。
* 资源优化。比如使用 Android Lint 删除冗余资源，资源文件最少化等。
* 图片优化。比如利用 AAPT 工具对 PNG 格式的图片做压缩处理，降低图片色彩位数等。
* 避免重复功能的库，使用 WebP图片格式等。
* 插件化。比如功能模块放在服务器上，按需下载，可以减少安装包大小。


